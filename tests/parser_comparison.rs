// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

//! Parser Comparison Tests - Compare Rust parser output with Godot 3 golden masters
//!
//! These tests parse .casp files with the Rust parser and compare the output
//! against golden master JSON files generated by the Godot 3 + GDScript parser.

use std::fs;
use serde_json::Value;

// NOTE: We cannot directly test the parser here because it requires Godot runtime.
// The parser uses godot::prelude::* types like Variant, GString, etc.
//
// These tests demonstrate the comparison pattern and validate that:
// 1. Golden masters are well-formed
// 2. We know what fields to compare
// 3. The comparison logic is correct
//
// Actual parser integration tests should be run within Godot using test_runner.rs

#[cfg(test)]
mod tests {
    use super::*;

    /// Load a golden master JSON file
    fn load_golden_master(path: &str) -> Value {
        let json_content = fs::read_to_string(path)
            .expect(&format!("Failed to load golden master: {}", path));
        serde_json::from_str(&json_content)
            .expect(&format!("Failed to parse golden master JSON: {}", path))
    }

    /// Validate the structure of a golden master
    fn validate_golden_master_structure(golden: &Value) {
        assert!(golden["metadata"].is_object(), "Golden master should have metadata");
        assert!(golden["variables"].is_object(), "Golden master should have variables");
        assert!(golden["states"].is_object(), "Golden master should have states");
        assert!(golden["subentities"].is_object(), "Golden master should have subentities");
        assert!(golden["transformed_data"].is_object(), "Golden master should have transformed_data");
    }

    #[test]
    fn test_golden_master_structure_test_character_complete() {
        let golden = load_golden_master("golden_masters/test_character_complete.json");
        validate_golden_master_structure(&golden);

        // Check metadata fields
        let metadata = &golden["metadata"];
        assert_eq!(metadata["name"].as_str().unwrap(), "Complete Test Fighter");
        assert_eq!(metadata["author"].as_str().unwrap(), "Parser Development Team");
        assert_eq!(metadata["description"].as_str().unwrap(),
            "A comprehensive character file testing all parser features");
        assert_eq!(metadata["version"].as_str().unwrap(), "2.0");
        assert_eq!(metadata["filepath"].as_str().unwrap(), "test_character_complete.casp");

        println!("✓ Golden master structure is valid");
    }

    #[test]
    fn test_golden_master_structure_baston_model() {
        let golden = load_golden_master("golden_masters/Baston-Model.json");
        validate_golden_master_structure(&golden);

        // Check metadata
        let metadata = &golden["metadata"];
        assert_eq!(metadata["name"].as_str().unwrap(), "Baston Labatte");
        assert_eq!(metadata["editorname"].as_str().unwrap(), "Baston Labatte (Custom Character)");

        // Check states count
        let states = golden["states"].as_object().unwrap();
        assert!(states.len() > 100, "Baston-Model should have many states");

        // Check specific states exist
        assert!(states.contains_key("Init"), "Should have Init state");
        assert!(states.contains_key("Stand"), "Should have Stand state");

        // Check variables count
        let variables = golden["variables"].as_object().unwrap();
        assert!(variables.len() > 0, "Baston-Model should have variables");

        println!("✓ Baston-Model golden master is valid");
        println!("  States: {}", states.len());
        println!("  Variables: {}", variables.len());
    }

    #[test]
    fn test_golden_master_structure_baston_2d() {
        let golden = load_golden_master("golden_masters/Baston-2D.json");
        validate_golden_master_structure(&golden);

        // Check metadata
        let metadata = &golden["metadata"];
        assert_eq!(metadata["name"].as_str().unwrap(), "Baston Labatte");
        assert_eq!(metadata["editorname"].as_str().unwrap(), "Baston 2D (Example Character)");
        assert_eq!(metadata["skeleton"].as_str().unwrap(),
            "res://castagne/examples/fighters/baston/Baston-Model.casp");

        // Check states
        let states = golden["states"].as_object().unwrap();
        assert!(states.contains_key("5H"), "Should have 5H state");
        assert!(states.contains_key("5L"), "Should have 5L state");
        assert!(states.contains_key("5M"), "Should have 5M state");

        // Check transformed data
        let graphics = &golden["transformed_data"]["Graphics"]["Defines"];
        assert_eq!(graphics["GRAPHICS_Scale"].as_i64().unwrap(), 3000);
        assert_eq!(graphics["GRAPHICS_UseSprites"].as_i64().unwrap(), 1);
        assert_eq!(graphics["GRAPHICS_UseModel"].as_i64().unwrap(), 0);

        println!("✓ Baston-2D golden master is valid");
    }

    #[test]
    fn test_golden_master_states_detailed() {
        let golden = load_golden_master("golden_masters/Baston-Model.json");

        // Check a specific state structure
        let states = &golden["states"];
        let init_state = &states["Init"];

        assert!(init_state.is_object(), "Init state should be an object");
        // States can have various fields depending on their definition

        println!("✓ State structures are valid");
    }

    #[test]
    fn test_golden_master_variables_detailed() {
        let golden = load_golden_master("golden_masters/Baston-Model.json");

        let variables = &golden["variables"];
        let var_count = variables.as_object().unwrap().len();

        println!("✓ Variables structure is valid");
        println!("  Total variables: {}", var_count);
    }

    /// This test demonstrates what a full parser comparison would look like
    /// Currently marked as ignored because it requires Godot runtime
    #[test]
    #[ignore]
    fn example_full_parser_comparison() {
        // Step 1: Load golden master
        let golden = load_golden_master("golden_masters/test_character_complete.json");

        // Step 2: Parse with Rust parser (requires Godot runtime)
        // This is what we WANT to do but can't in a standard cargo test:
        /*
        let mut parser = CastagneParser::new();
        let parsed = parser.create_full_character("test_character_complete.casp")
            .expect("Parser should succeed");

        // Step 3: Convert to JSON
        let rust_json: Value = parsed.to_json_value()
            .expect("Should serialize to JSON");

        // Step 4: Compare metadata
        assert_eq!(
            rust_json["metadata"]["name"],
            golden["metadata"]["name"],
            "Character name should match"
        );

        // Step 5: Compare variables count
        let rust_var_count = rust_json["variables"].as_object().unwrap().len();
        let golden_var_count = golden["variables"].as_object().unwrap().len();
        assert_eq!(
            rust_var_count,
            golden_var_count,
            "Variable count should match"
        );

        // Step 6: Compare states count
        let rust_state_count = rust_json["states"].as_object().unwrap().len();
        let golden_state_count = golden["states"].as_object().unwrap().len();
        assert_eq!(
            rust_state_count,
            golden_state_count,
            "State count should match"
        );
        */

        println!("✓ Full comparison pattern validated");
        println!("  Expected metadata name: {}", golden["metadata"]["name"]);
        println!("  Expected variables count: {}", golden["variables"].as_object().unwrap().len());
        println!("  Expected states count: {}", golden["states"].as_object().unwrap().len());
    }

    /// Helper function to compare two JSON values and report differences
    #[allow(dead_code)]
    fn compare_json_values(rust_value: &Value, golden_value: &Value, path: &str) -> Vec<String> {
        let mut differences = Vec::new();

        match (rust_value, golden_value) {
            (Value::Object(rust_obj), Value::Object(golden_obj)) => {
                // Check for missing keys
                for key in golden_obj.keys() {
                    if !rust_obj.contains_key(key) {
                        differences.push(format!("{}.{}: missing in Rust parser output", path, key));
                    }
                }

                // Compare common keys
                for (key, rust_val) in rust_obj.iter() {
                    if let Some(golden_val) = golden_obj.get(key) {
                        let new_path = if path.is_empty() {
                            key.clone()
                        } else {
                            format!("{}.{}", path, key)
                        };
                        differences.extend(compare_json_values(rust_val, golden_val, &new_path));
                    }
                }
            }
            (Value::Array(rust_arr), Value::Array(golden_arr)) => {
                if rust_arr.len() != golden_arr.len() {
                    differences.push(format!("{}: array length mismatch (Rust: {}, Golden: {})",
                        path, rust_arr.len(), golden_arr.len()));
                }
            }
            (rust_val, golden_val) => {
                if rust_val != golden_val {
                    differences.push(format!("{}: value mismatch (Rust: {:?}, Golden: {:?})",
                        path, rust_val, golden_val));
                }
            }
        }

        differences
    }
}
