// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

//! Example: How to compare Rust parser output against golden masters
//!
//! This test demonstrates the pattern for testing the Rust parser
//! against the golden master files generated by Godot 3 + GDScript parser.
//!
//! NOTE: This is currently a DEMONSTRATION. The Rust parser needs more
//! implementation before it can fully match the golden master output.

#[cfg(test)]
mod parser_comparison {
    use std::fs;
    use serde_json::Value;

    /// Example: Compare Rust parser metadata against golden master
    #[test]
    #[ignore] // Ignored because Rust parser needs more implementation
    fn example_compare_metadata() {
        // Step 1: Load the golden master
        let golden_json = load_golden_master("golden_masters/Baston-Model.json");
        let expected_metadata = &golden_json["metadata"];

        // Step 2: Parse with Rust parser
        // TODO: This requires the parser to work without Godot runtime
        // For now, this is just demonstrating the pattern
        /*
        let mut parser = CastagneParser::new();
        let rust_result = parser.create_full_character(
            "castagne/examples/fighters/baston/Baston-Model.casp"
        ).expect("Parser should succeed");

        // Step 3: Compare metadata
        assert_eq!(
            rust_result.metadata.name,
            expected_metadata["name"].as_str().unwrap(),
            "Character name should match"
        );

        assert_eq!(
            rust_result.metadata.editorname,
            expected_metadata["editorname"].as_str().unwrap(),
            "EditorName should match"
        );
        */

        println!("Expected metadata:");
        println!("  Name: {}", expected_metadata["name"]);
        println!("  EditorName: {}", expected_metadata["editorname"]);
        println!("\nRust parser comparison: TODO - implement parser first");
    }

    /// Example: Compare state counts
    #[test]
    #[ignore] // Ignored because Rust parser needs more implementation
    fn example_compare_states() {
        // Step 1: Load golden master
        let golden_json = load_golden_master("golden_masters/Baston-2D.json");
        let expected_states = &golden_json["states"];
        let expected_count = expected_states.as_object().unwrap().len();

        // Step 2: Parse with Rust parser
        /*
        let mut parser = CastagneParser::new();
        let rust_result = parser.create_full_character(
            "castagne/examples/fighters/baston/Baston-2D.casp"
        ).expect("Parser should succeed");

        // Step 3: Compare state count
        assert_eq!(
            rust_result.states.len(),
            expected_count,
            "State count should match"
        );

        // Step 4: Check specific states exist
        assert!(
            rust_result.states.contains_key("5H"),
            "State 5H should exist"
        );
        assert!(
            rust_result.states.contains_key("5L"),
            "State 5L should exist"
        );
        assert!(
            rust_result.states.contains_key("5M"),
            "State 5M should exist"
        );
        */

        println!("Expected state count: {}", expected_count);
        println!("Expected states include: 5H, 5L, 5M");
        println!("\nRust parser comparison: TODO - implement state parsing");
    }

    /// Example: Compare transformed data (Graphics)
    #[test]
    #[ignore] // Ignored because Rust parser needs more implementation
    fn example_compare_graphics_data() {
        // Step 1: Load golden master
        let golden_json = load_golden_master("golden_masters/Baston-2D.json");
        let graphics_defines = &golden_json["transformed_data"]["Graphics"]["Defines"];

        let expected_scale = graphics_defines["GRAPHICS_Scale"].as_i64().unwrap();
        let expected_use_sprites = graphics_defines["GRAPHICS_UseSprites"].as_i64().unwrap();
        let expected_use_model = graphics_defines["GRAPHICS_UseModel"].as_i64().unwrap();

        // Step 2: Parse with Rust parser
        /*
        let mut parser = CastagneParser::new();
        let rust_result = parser.create_full_character(
            "castagne/examples/fighters/baston/Baston-2D.casp"
        ).expect("Parser should succeed");

        // Step 3: Compare graphics data
        let rust_graphics = &rust_result.transformed_data.get("Graphics")
            .expect("Graphics data should exist");

        assert_eq!(
            rust_graphics.get("GRAPHICS_Scale").unwrap().parse::<i64>().unwrap(),
            expected_scale,
            "GRAPHICS_Scale should match"
        );

        assert_eq!(
            rust_graphics.get("GRAPHICS_UseSprites").unwrap().parse::<i64>().unwrap(),
            expected_use_sprites,
            "GRAPHICS_UseSprites should match"
        );

        assert_eq!(
            rust_graphics.get("GRAPHICS_UseModel").unwrap().parse::<i64>().unwrap(),
            expected_use_model,
            "GRAPHICS_UseModel should match"
        );
        */

        println!("Expected Graphics defines:");
        println!("  GRAPHICS_Scale: {}", expected_scale);
        println!("  GRAPHICS_UseSprites: {}", expected_use_sprites);
        println!("  GRAPHICS_UseModel: {}", expected_use_model);
        println!("\nRust parser comparison: TODO - implement specs parsing");
    }

    // Helper function to load golden master JSON
    fn load_golden_master(path: &str) -> Value {
        let json_content = fs::read_to_string(path)
            .expect(&format!("Failed to load golden master: {}", path));
        serde_json::from_str(&json_content)
            .expect(&format!("Failed to parse golden master JSON: {}", path))
    }

    /// Utility: Print full golden master structure (for debugging)
    #[test]
    #[ignore] // Run with: cargo test --test parser_comparison_example -- --ignored --nocapture
    fn inspect_golden_master_structure() {
        let golden_json = load_golden_master("golden_masters/Baston-Model.json");

        println!("=== Golden Master Structure ===\n");

        // Metadata
        println!("METADATA:");
        if let Some(metadata) = golden_json["metadata"].as_object() {
            for (key, value) in metadata {
                println!("  {}: {:?}", key, value);
            }
        }

        // Variables
        println!("\nVARIABLES: {} total", golden_json["variables"].as_object().unwrap().len());

        // States
        println!("STATES: {} total", golden_json["states"].as_object().unwrap().len());
        println!("  Sample states: {:?}",
            golden_json["states"].as_object().unwrap().keys().take(10).collect::<Vec<_>>()
        );

        // Transformed Data
        println!("\nTRANSFORMED DATA modules:");
        if let Some(transformed) = golden_json["transformed_data"].as_object() {
            for module_name in transformed.keys() {
                println!("  - {}", module_name);
            }
        }
    }
}
